---
title: Linux网络编程(一)：TCP基础概念
date: 2022-12-13 11:25:00
author: wenxy
top: true
hide: false
cover: false
summary: 介绍TCP基本概念
categories: Linux网络编程
tags:
  - Linux
  - 网络编程
keywords: Linux网络编程
---

TCP协议：即传输控制协议（Transmission Control Protocol）是一种面向连接的协议，为用户进程提供可靠的全双工字节流，TCP套接字是一种流套接字，TCP关心确认、超时和重传之类的细节。TCP可以使用IPv4和IPv6。

RTT：round-trip time，端与端之间的往返时间，TCP含有用于动态估算客户和服务器之间RTT的算法。

分节：TCP传递给IP的数据单元。

TCP字节序列号：TCP回给每个字节关联一个序列号用于对所发送的数据进行排序。

MSS：最大分节大小（Maximum segment size），发送SYN的TCP一端使用本字段通知对端它在本连接的每个TCP分节中愿意接受的最大数据量。

MTU：最大传输单元（Maximum transmission unit)，以太网的MTU是1500字节，当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片。

套接字：TCP每个端点的IP地址和端口号称为一个套接字。

套接字对：定义一个TCP连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识网络上的每个TCP连接。

三路握手：

客户端与服务器建立一个TCP连接，需要经历以下几个步骤：

1. 服务器处于被动打开的状态，也就是可以接收外来连接
2. 客户端通过调用connect发起主动打开，此时客户端会发送一个同步分节（SYN）给服务器，这个SYN会携带一个序列号j，用于通知服务器连接中发送的数据的初始序列号，SYN本身会占用一个序列号
3. 服务器收到SYN分节后，发送确认分节（ACK）和自己的SYN分节给客户端，ACK和SYN是一同发送的，所以使用一个分节。ACK中会携带一个序列号j+1，意思是通知客户端本端所期待的下一个序列号，SYN分节中会携带一个新的序列号K，这个序列号是通知客户端本端发送的数据的初始序列号
4. 客户端收到来自服务端的ACK分节和SYN分节后需要回复客户端一个ACK分节，同时携带序列号K+1，告知服务端本端期待的下一个序列号

至此一个TCP连接就建立完成了，由于整个过程中需要至少交换三组数据，因此称之为TCP的三路握手或三次握手，TCP三路握手连接示意图如下：

![TCP_connect](https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_connect.png)

TCP连接终止：

TCP连接的建立需要交换三个分节，而终止一个连接则通常需要交换四个分节，所以TCP连接的终止又叫四路分手。

TCP连接的终止需要经历以下几个步骤：

1. 主动关闭连接的一端的应用程序调用close执行主动关闭。该端的TCP会发送一个FIN分节，表示数据发送完毕
2. 接收到FIN分节的对端执行被动关闭。接收端会发送ACK给对端确认。FIN的接收也作为一个文件结束符通知给接收端的应用进程。此时主动关闭一端到被动关闭一端的数据流就关闭了
3. 被动关闭的一端在处理完数据后，应用进程调用close关闭套接字，这会导致它的TCP也发送一个FIN
4. 接收到这个FIN的原发送端TCP再发送一个确认给对端，此时被动关闭一端到主动关闭一端的数据流也关闭了

TCP连接终止时的分节也携带序列号，同时一个FIN分节也占用一个字节的序列号。至此TCP双向的数据流都完成关闭，TCP连接终止，TCP终止连接时的数据交换示意图如下：

![TCP_disconnect](https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_disconnect.png)

TCP连接的终止通常需要交换四组数据，但是步骤2和步骤3的分节合并成一个分节发送的可能性是存在的，而且步骤1的分节也是有可能随数据一起发送的。在步骤2和步骤3之间，主动关闭一端到被动关闭一端的数据流被关闭了，但是相反方向的数据流还未被关闭，这种状态称为班关闭（half-close）。

上述示意图中展示的FIN分节的发送都是通过close函数的调用发生的，但是在linux系统中，无论程序是怎样终止的，其打开的所有描述符都会被关闭，包括套接字描述符，此时也会导致本端的TCP发送一个FIN。

TCP状态转换图：

TCP涉及连接建立和终止的操作可以用状态转换图来说明：

![TCP_status](https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_status.png)

建立连接时的TCP状态转换：

TCP初始状态是CLOSED，作为客户端执行主动打开时，发送SYN分节后TCP状态会变为SYN_SENT，接收到来自服务端的ACK和SYN后会发送ACK分节，然后变为ESTABLISHED状态，这种状态表示TCP连接已经建立成功，可以进行数据传输，这也是绝大多数数据传送发生时的状态；作为服务端从CLOSED状态通过调用socket，bind，listen执行被动打开，此时服务器已经准备好接受新连接，服务端的TCP状态为LISTEN，此时如果收到SYN分节并发送ACK分节和自己的SYN分节，会转换成SYN_RCVD状态，在这个状态如果收到客户端发送的ACK分节，则转换为ESTABLISHED状态。

终止连接时的TCP状态转换：

如果本端调用close执行主动关闭，TCP发送FIN后会转换为FIN_WAIT_1状态，等到接收到对端发回的ACK分节后转换为FIN_WAIT_2状态，此时TCP连接已经处于半关闭状态状态，本端到对端的数据流已经关闭了，在FIN_WAIT_2状态下收到对端发送的FIN分节并回复ACK分节后TCP状态会转换为TIME_WAIT，在此状态等待最长2MSL的时间后变为CLOSED状态。如果本端是被动关闭的，在收到FIN分节并发送ACK后会从ESTABLISHED转换至CLOSE_WAIT状态，此时对端到本端的数据流已经关闭了，同样TCP连接处于半关闭状态。一段时间后本端发送FIN给对端后状态转换至LAST_ACK，等接收到对端的确认ACK后，状态转换至CLOSED。

TCP连接在传输数据时一端发送一个数据分组，对端在收到分组后会发送一个ACK回来，发送端如果在指定时间内没有收到ACK应答，会重传分组。所以如果我们只需要传送一个请求分组，使用TCP连接时，需要额外8个数据分组的开销（连接建立时三个，终止时四个，作为对端成功接收数据的ACK应答一个）；如果使用UDP，则只需要两个数据分组，一个用于承载数据，一个用于承载应答。

TIME_WAIT状态：

执行主动关闭的一端在发送最后一个ACK确认分节后会进入TIME_WAIT状态并等待最长2MSL时间后变成CLOSED状态。MSL(maximum segment lifetime)标志分节最长生命周期。这个时间一般为30秒到2分钟。所以TIME_WAIT持续时间一般为一分钟到四分钟。TIME_WAIT状态有两个存在的理由：1.可靠地实现TCP全双工连接的终止；2.允许老的重复分解在网络中消逝。对于第一个理由，假设主动关闭的一端最后发送的ACK分节丢失了，那么服务端会重新发送FIN，客户端就需要维持状态等待重新发送的FIN到达，然后再发送ACK，如果客户端不维持状态，那么在收到服务端重新发送的FIN分节后会发送RST作为应答，这个分节会被服务器解释成一个错误。对于第二个理由，如果一条TCP连接关闭后，一条新建立的TCP连接的两端使用了与旧连接相同的地址和端口号，那么新连接称为旧连接的化身。假设旧连接最后发送的数据分节因为超时重传了，但是数据分节的生命周期并没有结束，只是可能在网络中“迷路”了，重传的数据分节到达对端后连接终止，此时如果作为化身的新连接建立，原来的数据分节在新连接建立后到达了，它就会被误认为是属于新连接中的数据。为了防止这一情况的发生，发送端TCP会在TIME_WAIT状态等待2MSL的时间，TCP不会给处于TIME_WAIT状态的连接发起新的化身。由于TIME_WAIT的持续时间是MSL的两倍，这个时间足够让一个方向的数据分节存在MSL后被丢弃，另一个方向上的应答最多存在MSL后被丢弃。TCP通过TIME_WAIT机制保证了一个TCP连接建立时，之前使用同样的地址端口建立的TCP连接上的老的重复分节已经消逝在网络中了。



参考书目：《UNIX网络编程》、《TCP/IP详解 卷1》